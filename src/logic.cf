--Grammar for logic
entrypoints Sequent;

Seq. Sequent ::= [Form] "|-" Form "{" [Step] "}";

-- var form;
-- const form;

StepPrem.       Step ::= "prem" Form ";";
StepDecConst.   Step ::= "const" TermId ";";
StepDecVar.     Step ::= "var" TermId";";
StepDecFun.     Step ::= TermId "(" [TermId] ")" ";";
StepAssume.     Step ::= "assume" Form ";"; --"Isn't premise and assume same only for proof/subproof?"
StepProof.      Step ::= "{"[Step]"}"; 
StepForm.       Step ::= RuleId "[" [Arg] "]" Form ";";
terminator      Step "" ;

--var x
--const x
ArgRange.   Arg   ::= Integer "-" Integer;
ArgSub.   Arg   ::= Step;
ArgLit.   Arg   ::= Integer;
separator Arg   ",";

FormBot.  Form4 ::= "bot";
FormEq.   Form4 ::= Term "=" Term;
FormPred. Form4 ::= Pred;

FormAll.  Form3 ::= "all" TermId Form3;
FormSome. Form3 ::= "some" TermId Form3;
FormNot.  Form3 ::= "!" Form3;

FormAnd.  Form2 ::= Form2 "&" Form3; --left-associative(c convention)
FormOr.   Form2 ::= Form2 "|" Form3; --left-associative(c convention)

FormIf.   Form1 ::= Form2 "->" Form1; --right-associative(book)
coercions Form 4;
separator Form ",";

Pred. Pred ::= PredId Params;
Term. Term ::= TermId Params;

Params. Params ::= "(" [Term] ")";
params. Params ::= Nil;

define params n = Params [];

--Ugly but works?
Nil. Nil ::= "";

separator nonempty Term ",";

token PredId (upper);
token TermId (lower (letter | digit | '_' )*);
token RuleId (upper (letter | digit | '_' )*);

separator nonempty TermId ",";

comment "#";