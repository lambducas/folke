--Grammar for logic
Seq. Sequent ::= "if" [Form] "|-" Form "{" [Step] "}";

-- var form;
-- const form;

rules TermType ::= "var" | "const";

StepPrem.   Step ::= "prem" Form ";";
StepDecVar. Step ::= TermType TermId";";
StepDecFun. Step ::= TermId "(" [TermId] ")" ";";
StepAssume. Step ::= "assume" Form ";"; --"isent premise and assume same only for proof/subproof?"
StepProof.  Step ::= "{"[Step]"}"; 
StepForm.   Step ::= RuleId "[" [Arg] "]" Form ";";
terminator  Step "" ;

--var x
--const x
ArgSub.   Arg   ::= Step;
ArgLit.   Arg   ::= Integer;
separator Arg ",";

rules SymBot    ::= "bot" | "_|_";
rules SymEq     ::= "=";
rules SymAll    ::= "all";
rules SymSome   ::= "some";
rules SymNot    ::= "not" | "!";
rules SymAnd    ::= "and" | "&";
rules SymOr     ::= "or"  | "|";

FormBot.  Form4 ::= SymBot;
FormEq.   Form4 ::= Term SymEq Term;
FormPred. Form4 ::= Pred;

FormAll.  Form3 ::= SymAll TermId Form3;
FormSome. Form3 ::= SymSome TermId Form3;
FormNot.  Form3 ::= SymNot Form3;

FormAnd.  Form2 ::= Form2 SymAnd Form3; --left-associative(c convention)
FormOr.   Form2 ::= Form2 SymOr Form3; --left-associative(c convention)

FormIf.   Form1 ::= Form1 "->" Form2; --right-associative(book)
coercions Form 4;
separator Form ",";

Pred. Pred ::= PredId Params;
Term. Term ::= TermId Params;

rules Params  ::= "(" [Term] ")" | ;
separator nonempty Term ",";

token PredId (upper (letter | digit | '_' )*);
token TermId (lower (letter | digit | '_' )*);
token RuleId (upper (letter | digit | '_' )*);

separator nonempty TermId ",";

comment "#" ;