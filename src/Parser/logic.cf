--Grammar for logic
Seq. Sequent ::= "if" [Form] "|-" Form "{" [Step] "}";

-- var form;
-- const form;

rules TermType ::= "var" | "const";

StepPrem.   Step ::= "prem" Form ";"; -- OK
StepTerm.   Step ::= TermType Term ";"; -- TODO: FIX
-- StepTerm.   Step ::= Term "Assumed" ";";  
StepAssume. Step ::= "assume" Form ";"; -- OK
StepScope.  Step ::= "{"[Step]"}"; 
StepForm.   Step ::= RuleId "[" [Arg] "]" Form ";";
terminator  Step "" ;

--var x
--const x
ArgStep. Arg ::= Step;
ArgLit. Arg ::= Integer;
separator Arg ",";

FormBot.  Form4 ::= "bot";
FormEq.   Form4 ::= Term "=" Term;
FormPred. Form4 ::= Pred;

FormAll.  Form3 ::= "all" TermId Form3;
FormSome. Form3 ::= "some" TermId Form3;
FormNot.  Form3 ::= "!" Form3;

FormAnd.  Form2 ::= Form2 "&" Form3; --left-associative(c convention)
FormOr.   Form2 ::= Form2 "|" Form3; --left-associative(c convention)

FormIf.   Form1 ::= Form1 "->" Form2; --right-associative(book)
coercions Form 4;
separator Form ",";

Pred0. Pred ::= PredId;
PredN. Pred ::= PredId "(" [Term] ")";

TermVar. Term ::= TermId;
TermFun. Term ::= TermId "(" [Term] ")";
separator nonempty Term ",";

token PredId (upper (letter | digit | '_' )*);
token TermId (lower (letter | digit | '_' )*);
token RuleId (upper (letter | digit | '_' )*);

comment "#" ;