-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Logic.Par
  ( happyError
  , myLexer
  , pSequent
  , pTermType
  , pStep
  , pListStep
  , pArg
  , pListArg
  , pSymBot
  , pSymEq
  , pSymAll
  , pSymSome
  , pSymNot
  , pSymAnd
  , pSymOr
  , pForm4
  , pForm3
  , pForm2
  , pForm1
  , pForm
  , pListForm
  , pPred
  , pTerm
  , pListTerm
  ) where

import Prelude

import qualified Logic.Abs
import Logic.Lex

}

%name pSequent Sequent
%name pTermType TermType
%name pStep Step
%name pListStep ListStep
%name pArg Arg
%name pListArg ListArg
%name pSymBot SymBot
%name pSymEq SymEq
%name pSymAll SymAll
%name pSymSome SymSome
%name pSymNot SymNot
%name pSymAnd SymAnd
%name pSymOr SymOr
%name pForm4 Form4
%name pForm3 Form3
%name pForm2 Form2
%name pForm1 Form1
%name pForm Form
%name pListForm ListForm
%name pPred Pred
%name pTerm Term
%name pListTerm ListTerm
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'      { PT _ (TS _ 1)      }
  '&'      { PT _ (TS _ 2)      }
  '('      { PT _ (TS _ 3)      }
  ')'      { PT _ (TS _ 4)      }
  ','      { PT _ (TS _ 5)      }
  '->'     { PT _ (TS _ 6)      }
  ';'      { PT _ (TS _ 7)      }
  '='      { PT _ (TS _ 8)      }
  'Bot'    { PT _ (TS _ 9)      }
  '['      { PT _ (TS _ 10)     }
  ']'      { PT _ (TS _ 11)     }
  'all'    { PT _ (TS _ 12)     }
  'and'    { PT _ (TS _ 13)     }
  'assume' { PT _ (TS _ 14)     }
  'const'  { PT _ (TS _ 15)     }
  'if'     { PT _ (TS _ 16)     }
  'not'    { PT _ (TS _ 17)     }
  'or'     { PT _ (TS _ 18)     }
  'prem'   { PT _ (TS _ 19)     }
  'some'   { PT _ (TS _ 20)     }
  'var'    { PT _ (TS _ 21)     }
  '{'      { PT _ (TS _ 22)     }
  '|'      { PT _ (TS _ 23)     }
  '|-'     { PT _ (TS _ 24)     }
  '}'      { PT _ (TS _ 25)     }
  L_integ  { PT _ (TI $$)       }
  L_PredId { PT _ (T_PredId $$) }
  L_TermId { PT _ (T_TermId $$) }
  L_RuleId { PT _ (T_RuleId $$) }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

PredId :: { Logic.Abs.PredId }
PredId  : L_PredId { Logic.Abs.PredId $1 }

TermId :: { Logic.Abs.TermId }
TermId  : L_TermId { Logic.Abs.TermId $1 }

RuleId :: { Logic.Abs.RuleId }
RuleId  : L_RuleId { Logic.Abs.RuleId $1 }

Sequent :: { Logic.Abs.Sequent }
Sequent
  : 'if' ListForm '|-' Form '{' ListStep '}' { Logic.Abs.Seq $2 $4 $6 }

TermType :: { Logic.Abs.TermType }
TermType
  : 'var' { Logic.Abs.TermType_var }
  | 'const' { Logic.Abs.TermType_const }

Step :: { Logic.Abs.Step }
Step
  : 'prem' Form ';' { Logic.Abs.StepPrem $2 }
  | TermType TermId ';' { Logic.Abs.StepTerm $1 $2 }
  | 'assume' Form ';' { Logic.Abs.StepAssume $2 }
  | '{' ListStep '}' { Logic.Abs.StepScope $2 }
  | RuleId '[' ListArg ']' Form ';' { Logic.Abs.StepForm $1 $3 $5 }

ListStep :: { [Logic.Abs.Step] }
ListStep : {- empty -} { [] } | Step ListStep { (:) $1 $2 }

Arg :: { Logic.Abs.Arg }
Arg
  : Step { Logic.Abs.ArgStep $1 } | Integer { Logic.Abs.ArgLit $1 }

ListArg :: { [Logic.Abs.Arg] }
ListArg
  : {- empty -} { [] }
  | Arg { (:[]) $1 }
  | Arg ',' ListArg { (:) $1 $3 }

SymBot :: { Logic.Abs.SymBot }
SymBot : 'Bot' { Logic.Abs.SymBot_Bot }

SymEq :: { Logic.Abs.SymEq }
SymEq : '=' { Logic.Abs.SymEq1 }

SymAll :: { Logic.Abs.SymAll }
SymAll : 'all' { Logic.Abs.SymAll_all }

SymSome :: { Logic.Abs.SymSome }
SymSome : 'some' { Logic.Abs.SymSome_some }

SymNot :: { Logic.Abs.SymNot }
SymNot : 'not' { Logic.Abs.SymNot_not } | '!' { Logic.Abs.SymNot1 }

SymAnd :: { Logic.Abs.SymAnd }
SymAnd : 'and' { Logic.Abs.SymAnd_and } | '&' { Logic.Abs.SymAnd1 }

SymOr :: { Logic.Abs.SymOr }
SymOr : 'or' { Logic.Abs.SymOr_or } | '|' { Logic.Abs.SymOr1 }

Form4 :: { Logic.Abs.Form }
Form4
  : SymBot { Logic.Abs.FormBot $1 }
  | Term SymEq Term { Logic.Abs.FormEq $1 $2 $3 }
  | Pred { Logic.Abs.FormPred $1 }
  | '(' Form ')' { $2 }

Form3 :: { Logic.Abs.Form }
Form3
  : SymAll TermId Form3 { Logic.Abs.FormAll $1 $2 $3 }
  | SymSome TermId Form3 { Logic.Abs.FormSome $1 $2 $3 }
  | SymNot Form3 { Logic.Abs.FormNot $1 $2 }
  | Form4 { $1 }

Form2 :: { Logic.Abs.Form }
Form2
  : Form2 SymAnd Form3 { Logic.Abs.FormAnd $1 $2 $3 }
  | Form2 SymOr Form3 { Logic.Abs.FormOr $1 $2 $3 }
  | Form3 { $1 }

Form1 :: { Logic.Abs.Form }
Form1 : Form1 '->' Form2 { Logic.Abs.FormIf $1 $3 } | Form2 { $1 }

Form :: { Logic.Abs.Form }
Form : Form1 { $1 }

ListForm :: { [Logic.Abs.Form] }
ListForm
  : {- empty -} { [] }
  | Form { (:[]) $1 }
  | Form ',' ListForm { (:) $1 $3 }

Pred :: { Logic.Abs.Pred }
Pred
  : PredId { Logic.Abs.Pred0 $1 }
  | PredId '(' ListTerm ')' { Logic.Abs.PredN $1 $3 }

Term :: { Logic.Abs.Term }
Term
  : TermId { Logic.Abs.TermVar $1 }
  | TermId '(' ListTerm ')' { Logic.Abs.TermFun $1 $3 }

ListTerm :: { [Logic.Abs.Term] }
ListTerm : Term { (:[]) $1 } | Term ',' ListTerm { (:) $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

