-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Logic.Par
  ( happyError
  , myLexer
  , pSequent
  , pTermType
  , pStep
  , pListStep
  , pArg
  , pListArg
  , pSymBot
  , pForm4
  , pForm3
  , pForm2
  , pForm1
  , pForm
  , pListForm
  , pPred
  , pTerm
  , pListTerm
  ) where

import Prelude

import qualified Logic.Abs
import Logic.Lex

}

%name pSequent Sequent
%name pTermType TermType
%name pStep Step
%name pListStep ListStep
%name pArg Arg
%name pListArg ListArg
%name pSymBot SymBot
%name pForm4 Form4
%name pForm3 Form3
%name pForm2 Form2
%name pForm1 Form1
%name pForm Form
%name pListForm ListForm
%name pPred Pred
%name pTerm Term
%name pListTerm ListTerm
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'          { PT _ (TS _ 1)      }
  '&'          { PT _ (TS _ 2)      }
  '('          { PT _ (TS _ 3)      }
  ')'          { PT _ (TS _ 4)      }
  ','          { PT _ (TS _ 5)      }
  '->'         { PT _ (TS _ 6)      }
  ';'          { PT _ (TS _ 7)      }
  '='          { PT _ (TS _ 8)      }
  '['          { PT _ (TS _ 9)      }
  ']'          { PT _ (TS _ 10)     }
  'all'        { PT _ (TS _ 11)     }
  'assume'     { PT _ (TS _ 12)     }
  'bot'        { PT _ (TS _ 13)     }
  'const'      { PT _ (TS _ 14)     }
  'if'         { PT _ (TS _ 15)     }
  'prem'       { PT _ (TS _ 16)     }
  'some'       { PT _ (TS _ 17)     }
  'somesymbol' { PT _ (TS _ 18)     }
  'var'        { PT _ (TS _ 19)     }
  '{'          { PT _ (TS _ 20)     }
  '|'          { PT _ (TS _ 21)     }
  '|-'         { PT _ (TS _ 22)     }
  '}'          { PT _ (TS _ 23)     }
  L_integ      { PT _ (TI $$)       }
  L_PredId     { PT _ (T_PredId $$) }
  L_TermId     { PT _ (T_TermId $$) }
  L_RuleId     { PT _ (T_RuleId $$) }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

PredId :: { Logic.Abs.PredId }
PredId  : L_PredId { Logic.Abs.PredId $1 }

TermId :: { Logic.Abs.TermId }
TermId  : L_TermId { Logic.Abs.TermId $1 }

RuleId :: { Logic.Abs.RuleId }
RuleId  : L_RuleId { Logic.Abs.RuleId $1 }

Sequent :: { Logic.Abs.Sequent }
Sequent
  : 'if' ListForm '|-' Form '{' ListStep '}' { Logic.Abs.Seq $2 $4 $6 }

TermType :: { Logic.Abs.TermType }
TermType
  : 'var' { Logic.Abs.TermType_var }
  | 'const' { Logic.Abs.TermType_const }

Step :: { Logic.Abs.Step }
Step
  : 'prem' Form ';' { Logic.Abs.StepPrem $2 }
  | TermType Term ';' { Logic.Abs.StepTerm $1 $2 }
  | 'assume' Form ';' { Logic.Abs.StepAssume $2 }
  | '{' ListStep '}' { Logic.Abs.StepScope $2 }
  | RuleId '[' ListArg ']' Form ';' { Logic.Abs.StepForm $1 $3 $5 }

ListStep :: { [Logic.Abs.Step] }
ListStep : {- empty -} { [] } | Step ListStep { (:) $1 $2 }

Arg :: { Logic.Abs.Arg }
Arg
  : Step { Logic.Abs.ArgStep $1 } | Integer { Logic.Abs.ArgLit $1 }

ListArg :: { [Logic.Abs.Arg] }
ListArg
  : {- empty -} { [] }
  | Arg { (:[]) $1 }
  | Arg ',' ListArg { (:) $1 $3 }

SymBot :: { Logic.Abs.SymBot }
SymBot
  : 'bot' { Logic.Abs.SymBot_bot }
  | 'somesymbol' { Logic.Abs.SymBot_somesymbol }

Form4 :: { Logic.Abs.Form }
Form4
  : SymBot { Logic.Abs.FormBot $1 }
  | Term '=' Term { Logic.Abs.FormEq $1 $3 }
  | '(' Form ')' { $2 }

Form3 :: { Logic.Abs.Form }
Form3
  : 'all' Term Form { Logic.Abs.FormAll $2 $3 }
  | 'some' Term Form { Logic.Abs.FormSome $2 $3 }
  | '!' Form { Logic.Abs.FormNot $2 }
  | Form4 { $1 }

Form2 :: { Logic.Abs.Form }
Form2
  : Form '&' Form { Logic.Abs.FormAnd $1 $3 }
  | Form '|' Form { Logic.Abs.FormOr $1 $3 }
  | Form3 { $1 }

Form1 :: { Logic.Abs.Form }
Form1 : Form '->' Form { Logic.Abs.FormIf $1 $3 } | Form2 { $1 }

Form :: { Logic.Abs.Form }
Form : Pred { Logic.Abs.FormPred $1 } | Form1 { $1 }

ListForm :: { [Logic.Abs.Form] }
ListForm
  : {- empty -} { [] }
  | Form { (:[]) $1 }
  | Form ',' ListForm { (:) $1 $3 }

Pred :: { Logic.Abs.Pred }
Pred
  : PredId { Logic.Abs.Pred0 $1 }
  | PredId '(' ListTerm ')' { Logic.Abs.PredN $1 $3 }

Term :: { Logic.Abs.Term }
Term
  : TermId { Logic.Abs.TermVar $1 }
  | TermId '(' ListTerm ')' { Logic.Abs.TermFun $1 $3 }

ListTerm :: { [Logic.Abs.Term] }
ListTerm : Term { (:[]) $1 } | Term ',' ListTerm { (:) $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

