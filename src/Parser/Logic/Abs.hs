-- File generated by the BNF Converter (bnfc 2.9.5).

-- For GHC version 7.10 or higher

{-# LANGUAGE GADTs, KindSignatures, DataKinds #-}
{-# LANGUAGE LambdaCase #-}

{-# OPTIONS_GHC -fno-warn-unused-binds #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}
{-# OPTIONS_GHC -fno-warn-incomplete-patterns #-}
{-# OPTIONS_GHC -fno-warn-overlapping-patterns #-}

module Logic.Abs (Tree(..), Sequent, Step, Arg, Form, Pred, Term, Params, Nil, PredId, TermId, RuleId, params, johnMajorEq, module Logic.ComposOp) where

import Prelude (Char, Double, Integer, String, (.), (>), (&&), (==))
import qualified Prelude as P

import Logic.ComposOp

data Tag = Sequent_ | Step_ | Arg_ | Form_ | Pred_ | Term_ | Params_ | Nil_ | PredId_ | TermId_ | RuleId_
type Sequent = Tree 'Sequent_
type Step = Tree 'Step_
type Arg = Tree 'Arg_
type Form = Tree 'Form_
type Pred = Tree 'Pred_
type Term = Tree 'Term_
type Params = Tree 'Params_
type Nil = Tree 'Nil_
type PredId = Tree 'PredId_
type TermId = Tree 'TermId_
type RuleId = Tree 'RuleId_

data Tree (a :: Tag) where
    Seq :: [Form] -> Form -> [Step] -> Tree 'Sequent_
    StepPrem :: Form -> Tree 'Step_
    StepDecConst :: TermId -> Tree 'Step_
    StepDecVar :: TermId -> Tree 'Step_
    StepDecFun :: TermId -> [TermId] -> Tree 'Step_
    StepAssume :: Form -> Tree 'Step_
    StepProof :: [Step] -> Tree 'Step_
    StepForm :: RuleId -> [Arg] -> Form -> Tree 'Step_
    ArgSub :: Step -> Tree 'Arg_
    ArgLit :: Integer -> Tree 'Arg_
    FormBot :: Tree 'Form_
    FormEq :: Term -> Term -> Tree 'Form_
    FormPred :: Pred -> Tree 'Form_
    FormAll :: TermId -> Form -> Tree 'Form_
    FormSome :: TermId -> Form -> Tree 'Form_
    FormNot :: Form -> Tree 'Form_
    FormAnd :: Form -> Form -> Tree 'Form_
    FormOr :: Form -> Form -> Tree 'Form_
    FormIf :: Form -> Form -> Tree 'Form_
    Pred :: PredId -> Params -> Tree 'Pred_
    Term :: TermId -> Params -> Tree 'Term_
    Params :: [Term] -> Tree 'Params_
    Nil :: Tree 'Nil_
    PredId :: String -> Tree 'PredId_
    TermId :: String -> Tree 'TermId_
    RuleId :: String -> Tree 'RuleId_

instance Compos Tree where
  compos r a f = \case
      Seq forms form steps -> r Seq `a` P.foldr (\ x z -> r (:) `a` f x `a` z) (r []) forms `a` f form `a` P.foldr (\ x z -> r (:) `a` f x `a` z) (r []) steps
      StepPrem form -> r StepPrem `a` f form
      StepDecConst termid -> r StepDecConst `a` f termid
      StepDecVar termid -> r StepDecVar `a` f termid
      StepDecFun termid termids -> r StepDecFun `a` f termid `a` P.foldr (\ x z -> r (:) `a` f x `a` z) (r []) termids
      StepAssume form -> r StepAssume `a` f form
      StepProof steps -> r StepProof `a` P.foldr (\ x z -> r (:) `a` f x `a` z) (r []) steps
      StepForm ruleid args form -> r StepForm `a` f ruleid `a` P.foldr (\ x z -> r (:) `a` f x `a` z) (r []) args `a` f form
      ArgSub step -> r ArgSub `a` f step
      FormEq term0 term1 -> r FormEq `a` f term0 `a` f term1
      FormPred pred -> r FormPred `a` f pred
      FormAll termid form -> r FormAll `a` f termid `a` f form
      FormSome termid form -> r FormSome `a` f termid `a` f form
      FormNot form -> r FormNot `a` f form
      FormAnd form0 form1 -> r FormAnd `a` f form0 `a` f form1
      FormOr form0 form1 -> r FormOr `a` f form0 `a` f form1
      FormIf form0 form1 -> r FormIf `a` f form0 `a` f form1
      Pred predid params -> r Pred `a` f predid `a` f params
      Term termid params -> r Term `a` f termid `a` f params
      Params terms -> r Params `a` P.foldr (\ x z -> r (:) `a` f x `a` z) (r []) terms
      t -> r t

instance P.Show (Tree c) where
  showsPrec n = \case
    Seq forms form steps -> opar . P.showString "Seq" . P.showChar ' ' . P.showsPrec 1 forms . P.showChar ' ' . P.showsPrec 1 form . P.showChar ' ' . P.showsPrec 1 steps . cpar
    StepPrem form -> opar . P.showString "StepPrem" . P.showChar ' ' . P.showsPrec 1 form . cpar
    StepDecConst termid -> opar . P.showString "StepDecConst" . P.showChar ' ' . P.showsPrec 1 termid . cpar
    StepDecVar termid -> opar . P.showString "StepDecVar" . P.showChar ' ' . P.showsPrec 1 termid . cpar
    StepDecFun termid termids -> opar . P.showString "StepDecFun" . P.showChar ' ' . P.showsPrec 1 termid . P.showChar ' ' . P.showsPrec 1 termids . cpar
    StepAssume form -> opar . P.showString "StepAssume" . P.showChar ' ' . P.showsPrec 1 form . cpar
    StepProof steps -> opar . P.showString "StepProof" . P.showChar ' ' . P.showsPrec 1 steps . cpar
    StepForm ruleid args form -> opar . P.showString "StepForm" . P.showChar ' ' . P.showsPrec 1 ruleid . P.showChar ' ' . P.showsPrec 1 args . P.showChar ' ' . P.showsPrec 1 form . cpar
    ArgSub step -> opar . P.showString "ArgSub" . P.showChar ' ' . P.showsPrec 1 step . cpar
    ArgLit integer -> opar . P.showString "ArgLit" . P.showChar ' ' . P.showsPrec 1 integer . cpar
    FormBot -> P.showString "FormBot"
    FormEq term0 term1 -> opar . P.showString "FormEq" . P.showChar ' ' . P.showsPrec 1 term0 . P.showChar ' ' . P.showsPrec 1 term1 . cpar
    FormPred pred -> opar . P.showString "FormPred" . P.showChar ' ' . P.showsPrec 1 pred . cpar
    FormAll termid form -> opar . P.showString "FormAll" . P.showChar ' ' . P.showsPrec 1 termid . P.showChar ' ' . P.showsPrec 1 form . cpar
    FormSome termid form -> opar . P.showString "FormSome" . P.showChar ' ' . P.showsPrec 1 termid . P.showChar ' ' . P.showsPrec 1 form . cpar
    FormNot form -> opar . P.showString "FormNot" . P.showChar ' ' . P.showsPrec 1 form . cpar
    FormAnd form0 form1 -> opar . P.showString "FormAnd" . P.showChar ' ' . P.showsPrec 1 form0 . P.showChar ' ' . P.showsPrec 1 form1 . cpar
    FormOr form0 form1 -> opar . P.showString "FormOr" . P.showChar ' ' . P.showsPrec 1 form0 . P.showChar ' ' . P.showsPrec 1 form1 . cpar
    FormIf form0 form1 -> opar . P.showString "FormIf" . P.showChar ' ' . P.showsPrec 1 form0 . P.showChar ' ' . P.showsPrec 1 form1 . cpar
    Pred predid params -> opar . P.showString "Pred" . P.showChar ' ' . P.showsPrec 1 predid . P.showChar ' ' . P.showsPrec 1 params . cpar
    Term termid params -> opar . P.showString "Term" . P.showChar ' ' . P.showsPrec 1 termid . P.showChar ' ' . P.showsPrec 1 params . cpar
    Params terms -> opar . P.showString "Params" . P.showChar ' ' . P.showsPrec 1 terms . cpar
    Nil -> P.showString "Nil"
    PredId str -> opar . P.showString "PredId" . P.showChar ' ' . P.showsPrec 1 str . cpar
    TermId str -> opar . P.showString "TermId" . P.showChar ' ' . P.showsPrec 1 str . cpar
    RuleId str -> opar . P.showString "RuleId" . P.showChar ' ' . P.showsPrec 1 str . cpar
    where
    opar = if n > 0 then P.showChar '(' else P.id
    cpar = if n > 0 then P.showChar ')' else P.id

instance P.Eq (Tree c) where (==) = johnMajorEq

johnMajorEq :: Tree a -> Tree b -> P.Bool
johnMajorEq (Seq forms form steps) (Seq forms_ form_ steps_) = forms == forms_ && form == form_ && steps == steps_
johnMajorEq (StepPrem form) (StepPrem form_) = form == form_
johnMajorEq (StepDecConst termid) (StepDecConst termid_) = termid == termid_
johnMajorEq (StepDecVar termid) (StepDecVar termid_) = termid == termid_
johnMajorEq (StepDecFun termid termids) (StepDecFun termid_ termids_) = termid == termid_ && termids == termids_
johnMajorEq (StepAssume form) (StepAssume form_) = form == form_
johnMajorEq (StepProof steps) (StepProof steps_) = steps == steps_
johnMajorEq (StepForm ruleid args form) (StepForm ruleid_ args_ form_) = ruleid == ruleid_ && args == args_ && form == form_
johnMajorEq (ArgSub step) (ArgSub step_) = step == step_
johnMajorEq (ArgLit integer) (ArgLit integer_) = integer == integer_
johnMajorEq FormBot FormBot = P.True
johnMajorEq (FormEq term0 term1) (FormEq term0_ term1_) = term0 == term0_ && term1 == term1_
johnMajorEq (FormPred pred) (FormPred pred_) = pred == pred_
johnMajorEq (FormAll termid form) (FormAll termid_ form_) = termid == termid_ && form == form_
johnMajorEq (FormSome termid form) (FormSome termid_ form_) = termid == termid_ && form == form_
johnMajorEq (FormNot form) (FormNot form_) = form == form_
johnMajorEq (FormAnd form0 form1) (FormAnd form0_ form1_) = form0 == form0_ && form1 == form1_
johnMajorEq (FormOr form0 form1) (FormOr form0_ form1_) = form0 == form0_ && form1 == form1_
johnMajorEq (FormIf form0 form1) (FormIf form0_ form1_) = form0 == form0_ && form1 == form1_
johnMajorEq (Pred predid params) (Pred predid_ params_) = predid == predid_ && params == params_
johnMajorEq (Term termid params) (Term termid_ params_) = termid == termid_ && params == params_
johnMajorEq (Params terms) (Params terms_) = terms == terms_
johnMajorEq Nil Nil = P.True
johnMajorEq (PredId str) (PredId str_) = str == str_
johnMajorEq (TermId str) (TermId str_) = str == str_
johnMajorEq (RuleId str) (RuleId str_) = str == str_
johnMajorEq _ _ = P.False

instance P.Ord (Tree c) where
  compare x y = P.compare (index x) (index y) `P.mappend` compareSame x y

index :: Tree c -> P.Int
index (Seq _ _ _) = 0
index (StepPrem _) = 1
index (StepDecConst _) = 2
index (StepDecVar _) = 3
index (StepDecFun _ _) = 4
index (StepAssume _) = 5
index (StepProof _) = 6
index (StepForm _ _ _) = 7
index (ArgSub _) = 8
index (ArgLit _) = 9
index (FormBot ) = 10
index (FormEq _ _) = 11
index (FormPred _) = 12
index (FormAll _ _) = 13
index (FormSome _ _) = 14
index (FormNot _) = 15
index (FormAnd _ _) = 16
index (FormOr _ _) = 17
index (FormIf _ _) = 18
index (Pred _ _) = 19
index (Term _ _) = 20
index (Params _) = 21
index (Nil ) = 22
index (PredId _) = 23
index (TermId _) = 24
index (RuleId _) = 25

compareSame :: Tree c -> Tree c -> P.Ordering
compareSame (Seq forms form steps) (Seq forms_ form_ steps_) = P.mappend (P.compare forms forms_) (P.mappend (P.compare form form_) (P.compare steps steps_))
compareSame (StepPrem form) (StepPrem form_) = P.compare form form_
compareSame (StepDecConst termid) (StepDecConst termid_) = P.compare termid termid_
compareSame (StepDecVar termid) (StepDecVar termid_) = P.compare termid termid_
compareSame (StepDecFun termid termids) (StepDecFun termid_ termids_) = P.mappend (P.compare termid termid_) (P.compare termids termids_)
compareSame (StepAssume form) (StepAssume form_) = P.compare form form_
compareSame (StepProof steps) (StepProof steps_) = P.compare steps steps_
compareSame (StepForm ruleid args form) (StepForm ruleid_ args_ form_) = P.mappend (P.compare ruleid ruleid_) (P.mappend (P.compare args args_) (P.compare form form_))
compareSame (ArgSub step) (ArgSub step_) = P.compare step step_
compareSame (ArgLit integer) (ArgLit integer_) = P.compare integer integer_
compareSame FormBot FormBot = P.EQ
compareSame (FormEq term0 term1) (FormEq term0_ term1_) = P.mappend (P.compare term0 term0_) (P.compare term1 term1_)
compareSame (FormPred pred) (FormPred pred_) = P.compare pred pred_
compareSame (FormAll termid form) (FormAll termid_ form_) = P.mappend (P.compare termid termid_) (P.compare form form_)
compareSame (FormSome termid form) (FormSome termid_ form_) = P.mappend (P.compare termid termid_) (P.compare form form_)
compareSame (FormNot form) (FormNot form_) = P.compare form form_
compareSame (FormAnd form0 form1) (FormAnd form0_ form1_) = P.mappend (P.compare form0 form0_) (P.compare form1 form1_)
compareSame (FormOr form0 form1) (FormOr form0_ form1_) = P.mappend (P.compare form0 form0_) (P.compare form1 form1_)
compareSame (FormIf form0 form1) (FormIf form0_ form1_) = P.mappend (P.compare form0 form0_) (P.compare form1 form1_)
compareSame (Pred predid params) (Pred predid_ params_) = P.mappend (P.compare predid predid_) (P.compare params params_)
compareSame (Term termid params) (Term termid_ params_) = P.mappend (P.compare termid termid_) (P.compare params params_)
compareSame (Params terms) (Params terms_) = P.compare terms terms_
compareSame Nil Nil = P.EQ
compareSame (PredId str) (PredId str_) = P.compare str str_
compareSame (TermId str) (TermId str_) = P.compare str str_
compareSame (RuleId str) (RuleId str_) = P.compare str str_
compareSame _ _ = P.error "BNFC error: compareSame"

params :: Nil -> Params
params = \ n -> Params []

