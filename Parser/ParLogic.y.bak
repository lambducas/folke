-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParLogic
  ( happyError
  , myLexer
  , pSequent
  , pTermType
  , pStep
  , pListStep
  , pArg
  , pListArg
  , pSymBot
  , pForm4
  , pForm3
  , pForm2
  , pForm1
  , pForm
  , pListForm
  , pPred
  , pTerm
  , pListTerm
  ) where

import Prelude

import qualified AbsLogic
import LexLogic

}

%name pSequent Sequent
%name pTermType TermType
%name pStep Step
%name pListStep ListStep
%name pArg Arg
%name pListArg ListArg
%name pSymBot SymBot
%name pForm4 Form4
%name pForm3 Form3
%name pForm2 Form2
%name pForm1 Form1
%name pForm Form
%name pListForm ListForm
%name pPred Pred
%name pTerm Term
%name pListTerm ListTerm
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'          { PT _ (TS _ 1)      }
  '&'          { PT _ (TS _ 2)      }
  '('          { PT _ (TS _ 3)      }
  ')'          { PT _ (TS _ 4)      }
  ','          { PT _ (TS _ 5)      }
  '->'         { PT _ (TS _ 6)      }
  ':'          { PT _ (TS _ 7)      }
  ';'          { PT _ (TS _ 8)      }
  '='          { PT _ (TS _ 9)      }
  'Assume'     { PT _ (TS _ 10)     }
  'Prem'       { PT _ (TS _ 11)     }
  '['          { PT _ (TS _ 12)     }
  ']'          { PT _ (TS _ 13)     }
  'all'        { PT _ (TS _ 14)     }
  'bot'        { PT _ (TS _ 15)     }
  'if'         { PT _ (TS _ 16)     }
  'some'       { PT _ (TS _ 17)     }
  'somesymbol' { PT _ (TS _ 18)     }
  'var'        { PT _ (TS _ 19)     }
  '{'          { PT _ (TS _ 20)     }
  '|'          { PT _ (TS _ 21)     }
  '|-'         { PT _ (TS _ 22)     }
  '}'          { PT _ (TS _ 23)     }
  L_ArgId      { PT _ (T_ArgId $$)  }
  L_PredId     { PT _ (T_PredId $$) }
  L_TermId     { PT _ (T_TermId $$) }
  L_RuleId     { PT _ (T_RuleId $$) }

%%

ArgId :: { AbsLogic.ArgId }
ArgId  : L_ArgId { AbsLogic.ArgId $1 }

PredId :: { AbsLogic.PredId }
PredId  : L_PredId { AbsLogic.PredId $1 }

TermId :: { AbsLogic.TermId }
TermId  : L_TermId { AbsLogic.TermId $1 }

RuleId :: { AbsLogic.RuleId }
RuleId  : L_RuleId { AbsLogic.RuleId $1 }

Sequent :: { AbsLogic.Sequent }
Sequent
  : 'if' ListForm '|-' Form ';' ListStep { AbsLogic.Seq $2 $4 $6 }

TermType :: { AbsLogic.TermType }
TermType
  : 'var' { AbsLogic.TermType_var }
  | {- empty -} { AbsLogic.TermType1 }

Step :: { AbsLogic.Step }
Step
  : Form ':' 'Prem' ';' { AbsLogic.StepPrem $1 }
  | TermType ':' Term ';' { AbsLogic.StepTerm $1 $3 }
  | 'Assume' Form ';' { AbsLogic.StepAssume $2 }
  | '{' ListStep '}' ';' { AbsLogic.StepScope $2 }
  | RuleId '[' ListArg ']' Form ';' { AbsLogic.StepForm $1 $3 $5 }

ListStep :: { [AbsLogic.Step] }
ListStep : {- empty -} { [] } | Step ListStep { (:) $1 $2 }

Arg :: { AbsLogic.Arg }
Arg : ArgId { AbsLogic.ArgLit $1 }

ListArg :: { [AbsLogic.Arg] }
ListArg
  : {- empty -} { [] }
  | Arg { (:[]) $1 }
  | Arg ',' ListArg { (:) $1 $3 }

SymBot :: { AbsLogic.SymBot }
SymBot
  : 'bot' { AbsLogic.SymBot_bot }
  | 'somesymbol' { AbsLogic.SymBot_somesymbol }

Form4 :: { AbsLogic.Form }
Form4
  : SymBot { AbsLogic.FormBot $1 }
  | Term '=' Term { AbsLogic.FormEq $1 $3 }
  | '(' Form ')' { $2 }

Form3 :: { AbsLogic.Form }
Form3
  : 'all' Term Form { AbsLogic.FormAll $2 $3 }
  | 'some' Term Form { AbsLogic.FormSome $2 $3 }
  | '!' Form { AbsLogic.FormNot $2 }
  | Form4 { $1 }

Form2 :: { AbsLogic.Form }
Form2
  : Form '&' Form { AbsLogic.FormAnd $1 $3 }
  | Form '|' Form { AbsLogic.FormOr $1 $3 }
  | Form3 { $1 }

Form1 :: { AbsLogic.Form }
Form1 : Form '->' Form { AbsLogic.FormIf $1 $3 } | Form2 { $1 }

Form :: { AbsLogic.Form }
Form : Pred { AbsLogic.FormPred $1 } | Form1 { $1 }

ListForm :: { [AbsLogic.Form] }
ListForm
  : {- empty -} { [] }
  | Form { (:[]) $1 }
  | Form ',' ListForm { (:) $1 $3 }

Pred :: { AbsLogic.Pred }
Pred
  : PredId { AbsLogic.Pred0 $1 }
  | PredId '(' ListTerm ')' { AbsLogic.PredN $1 $3 }

Term :: { AbsLogic.Term }
Term
  : TermId { AbsLogic.TermVar $1 }
  | TermId '(' ListTerm ')' { AbsLogic.TermFun $1 $3 }

ListTerm :: { [AbsLogic.Term] }
ListTerm : Term { (:[]) $1 } | Term ',' ListTerm { (:) $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

