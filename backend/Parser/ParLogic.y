-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParLogic
  ( happyError
  , myLexer
  , pSequent
  , pStep
  , pListStep
  , pArg
  , pListArg
  , pForm4
  , pForm3
  , pForm2
  , pForm1
  , pForm
  , pListForm
  , pPred
  , pVar
  , pFun
  , pTerm
  , pListTerm
  ) where

import Prelude

import qualified AbsLogic
import LexLogic

}

%name pSequent Sequent
%name pStep Step
%name pListStep ListStep
%name pArg Arg
%name pListArg ListArg
%name pForm4 Form4
%name pForm3 Form3
%name pForm2 Form2
%name pForm1 Form1
%name pForm Form
%name pListForm ListForm
%name pPred Pred
%name pVar Var
%name pFun Fun
%name pTerm Term
%name pListTerm ListTerm
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'       { PT _ (TS _ 1)      }
  '&'       { PT _ (TS _ 2)      }
  '('       { PT _ (TS _ 3)      }
  ')'       { PT _ (TS _ 4)      }
  ','       { PT _ (TS _ 5)      }
  '->'      { PT _ (TS _ 6)      }
  ':'       { PT _ (TS _ 7)      }
  ';'       { PT _ (TS _ 8)      }
  '='       { PT _ (TS _ 9)      }
  'Assumed' { PT _ (TS _ 10)     }
  'Prem'    { PT _ (TS _ 11)     }
  'all'     { PT _ (TS _ 12)     }
  'bot'     { PT _ (TS _ 13)     }
  'if'      { PT _ (TS _ 14)     }
  'some'    { PT _ (TS _ 15)     }
  '{'       { PT _ (TS _ 16)     }
  '|'       { PT _ (TS _ 17)     }
  '|-'      { PT _ (TS _ 18)     }
  '}'       { PT _ (TS _ 19)     }
  L_ArgId   { PT _ (T_ArgId $$)  }
  L_PredId  { PT _ (T_PredId $$) }
  L_VarId   { PT _ (T_VarId $$)  }
  L_Ident   { PT _ (TV $$)       }
  L_PIdent  { PT _ (T_PIdent _)  }

%%

ArgId :: { AbsLogic.ArgId }
ArgId  : L_ArgId { AbsLogic.ArgId $1 }

PredId :: { AbsLogic.PredId }
PredId  : L_PredId { AbsLogic.PredId $1 }

VarId :: { AbsLogic.VarId }
VarId  : L_VarId { AbsLogic.VarId $1 }

Ident :: { AbsLogic.Ident }
Ident  : L_Ident { AbsLogic.Ident $1 }

PIdent :: { AbsLogic.PIdent }
PIdent  : L_PIdent { AbsLogic.PIdent (mkPosToken $1) }

Sequent :: { AbsLogic.Sequent }
Sequent
  : 'if' ListForm '|-' Form ';' ListStep { AbsLogic.Seq $2 $4 $6 }

Step :: { AbsLogic.Step }
Step
  : Form ':' 'Prem' ';' { AbsLogic.StepPrem $1 }
  | Var ':' 'Assumed' ';' { AbsLogic.StepFree $1 }
  | Form ':' 'Assumed' ';' { AbsLogic.StepAssume $1 }
  | '{' ListStep '}' ';' { AbsLogic.StepScope $2 }
  | Form ':' '(' ListArg ')' ';' { AbsLogic.StepForm $1 $4 }

ListStep :: { [AbsLogic.Step] }
ListStep : {- empty -} { [] } | Step ListStep { (:) $1 $2 }

Arg :: { AbsLogic.Arg }
Arg : ArgId { AbsLogic.ArgLit $1 }

ListArg :: { [AbsLogic.Arg] }
ListArg
  : {- empty -} { [] }
  | Arg { (:[]) $1 }
  | Arg ',' ListArg { (:) $1 $3 }

Form4 :: { AbsLogic.Form }
Form4
  : 'bot' { AbsLogic.FormBot }
  | Term '=' Term { AbsLogic.FormEq $1 $3 }
  | '(' Form ')' { $2 }

Form3 :: { AbsLogic.Form }
Form3
  : 'all' Var Form { AbsLogic.FormAll $2 $3 }
  | 'some' Var Form { AbsLogic.FormSome $2 $3 }
  | '!' Form { AbsLogic.FormNot $2 }
  | Form4 { $1 }

Form2 :: { AbsLogic.Form }
Form2
  : Form '&' Form { AbsLogic.FormAnd $1 $3 }
  | Form '|' Form { AbsLogic.FormOr $1 $3 }
  | Form3 { $1 }

Form1 :: { AbsLogic.Form }
Form1 : Form '->' Form { AbsLogic.FormIf $1 $3 } | Form2 { $1 }

Form :: { AbsLogic.Form }
Form : Pred { AbsLogic.FormPred $1 } | Form1 { $1 }

ListForm :: { [AbsLogic.Form] }
ListForm
  : {- empty -} { [] }
  | Form { (:[]) $1 }
  | Form ',' ListForm { (:) $1 $3 }

Pred :: { AbsLogic.Pred }
Pred
  : PredId '(' ListTerm ')' { AbsLogic.PredN $1 $3 }
  | PredId { AbsLogic.Pred0 $1 }

Var :: { AbsLogic.Var }
Var : VarId { AbsLogic.VarLit $1 }

Fun :: { AbsLogic.Fun }
Fun : VarId '(' ListTerm ')' { AbsLogic.FunLit $1 $3 }

Term :: { AbsLogic.Term }
Term : Var { AbsLogic.TermVar $1 } | Fun { AbsLogic.TermFun $1 }

ListTerm :: { [AbsLogic.Term] }
ListTerm
  : {- empty -} { [] }
  | Term { (:[]) $1 }
  | Term ',' ListTerm { (:) $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

